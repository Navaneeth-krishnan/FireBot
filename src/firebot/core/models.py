"""Core data models for FireBot trading platform."""

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field, model_validator


class SignalDirection(Enum):
    """Direction of a trading signal."""

    LONG = 1
    SHORT = -1
    NEUTRAL = 0


class OrderType(Enum):
    """Type of order to execute."""

    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"


class OrderSide(Enum):
    """Side of the order (buy or sell)."""

    BUY = "buy"
    SELL = "sell"


class OHLCV(BaseModel):
    """Open-High-Low-Close-Volume price data."""

    timestamp: datetime
    symbol: str = Field(min_length=1)
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal = Field(ge=0)
    resolution: str = Field(default="1h", pattern=r"^\d+[smhd]$|^tick$")

    model_config = {"frozen": True}

    @model_validator(mode="after")
    def validate_price_relationships(self) -> "OHLCV":
        """Validate that high >= low and all prices are consistent."""
        if self.high < self.low:
            raise ValueError("high must be >= low")
        return self


class Signal(BaseModel):
    """Trading signal generated by a strategy."""

    timestamp: datetime
    symbol: str = Field(min_length=1)
    direction: SignalDirection
    confidence: float = Field(ge=0.0, le=1.0)
    strategy_id: str = Field(min_length=1)
    metadata: dict[str, Any] = Field(default_factory=dict)

    model_config = {"frozen": True}


class Order(BaseModel):
    """Order to be executed by the trading engine."""

    id: str = Field(min_length=1)
    timestamp: datetime
    symbol: str = Field(min_length=1)
    side: OrderSide
    order_type: OrderType
    quantity: Decimal = Field(gt=0)
    price: Decimal | None = None
    strategy_id: str = Field(min_length=1)
    status: str = Field(default="pending")

    model_config = {"frozen": True}


class Position(BaseModel):
    """Current holding of an asset."""

    symbol: str = Field(min_length=1)
    quantity: Decimal
    entry_price: Decimal
    current_price: Decimal
    realized_pnl: Decimal = Decimal("0")
    strategy_id: str = Field(min_length=1)

    @property
    def unrealized_pnl(self) -> Decimal:
        """Calculate unrealized profit/loss."""
        return (self.current_price - self.entry_price) * self.quantity

    @property
    def market_value(self) -> Decimal:
        """Calculate current market value of position."""
        return self.current_price * self.quantity


class Portfolio(BaseModel):
    """Aggregate portfolio state for a strategy."""

    strategy_id: str = Field(min_length=1)
    cash: Decimal
    positions: dict[str, Position] = Field(default_factory=dict)
    high_water_mark: Decimal | None = None
    total_pnl: Decimal = Decimal("0")

    @property
    def total_value(self) -> Decimal:
        """Calculate total portfolio value (cash + positions)."""
        position_value = sum(
            (p.current_price * p.quantity for p in self.positions.values()),
            Decimal("0"),
        )
        return self.cash + position_value

    @property
    def drawdown(self) -> Decimal:
        """Calculate current drawdown from high water mark."""
        if self.high_water_mark is None or self.high_water_mark == 0:
            return Decimal("0")
        current = self.total_value
        return (self.high_water_mark - current) / self.high_water_mark
